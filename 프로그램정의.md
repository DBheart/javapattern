GOF 디자인 패턴은 잘만들었다. 그것을 통해서 앞으로 가야할바를 명시해볼예정이다.
기초가 잘되어야지 뒤가 있듯이... 과거를 살펴보고 현재를 보고 미래를 살펴보자.

프로그램에 대해서 살펴보고, 디자인패턴의 근간인 객체지향에 대해서 살펴보고, 디자인패턴을 공부할것이다.
디자인 패턴에서 어떻게 프로그램을 구성할것인지 생각할수 있는 근간을 마련해볼것이다.

디자인 패턴은 하나의 소통언어가 될수 있지 않을까한다. 그 프로젝트, 그 팀에서 어떻게 만들것인가의 최소 소통방법이 될수 있을것 같다.

> 사상의학(태양인, 태음인, 소양인, 소음인)이라는게 있다. 어느날 너무~ 궁금해서 한의사 선생님에게 물어봤다. 
> 저는 소양인인가요? 태음인인가요? 항간에 떠도는 자료로는 무엇인지 모르겠어요.
> 의사선생님 왈 : 소화가 느리고, 머리가 뜨겁고, 배가차고, 손발이 따뜻한게 환자님 체질이에요. 4가지로 나눌수 없어요.
>> 프로젝트, 팀, 개인의 패턴으로 소통할수 있게 공통분모로 생각을 가질수 있게 하는게 진정한 패턴정신 아닐까?

## 프로그램 분류
1. 절차적 프로그래밍
1.2 구조적 프로그래밍(???)
1.5 WEB의 발전, 세션단위(stateless)
2. 객체지향적 프로그래밍\
2.5 데이터베이스 시스템(대용량 처리를 위한.. : 트랜잭션 이슈 처리)
3. 비동기 프로그래밍
4. 함수형 프로그래밍

절차적 프로그래밍은 작은 단위의 프로그램을 할때 좋다. 
하지만 점점 사람들은 많이 사용하게 되었고 프로그램들을 묶은 시스템 개념으로 만들게 되었다.
큰 시스템은 설계를 위한 형식이 필요하게 되었고, 그것을 만족한것이 객체지향 프로그래밍이었다.
하지만 객체지향에 적응 하지 못했던, 기존의 개발자들이 많아 졌다. 
그래서 객체지향의 대표주자(?) 자바가 한참 유행한떄에는 데이터베이스 시스템의 부흥기가 왔다.
제일 중요한 데이터를 다루는 것을 절차지향적인 SQL, DBMS 펑션, 프로시져, DBMS 패키지, 심지어는 SAP에 넘기게 되었다.
하지만 세월은 또 변했다. 사람들은 객체지향에 익숙해졌지만, 이번에는 시스템이 문제였다.
지금 시도되고 있는 함수형 프로그래밍(하지만 시도되고 있다기에는.. 나온지 벌써 10년은 되었다)
사람들은 적응하고 있는중이다. 

절차적 프로그래밍이 그랬듯이 언어는 함수형 프로그래밍도 객체지향적으로 사람들은 짤것이다. 
함수형 프로그래밍이 많이 쓰는 그날이 오기까지말이다.. 

앞으로 객체지향에 익숙한 사람들에게 함수형을 어떻게 더욱 익숙하게 할것인가와 어떻게 변해갈지 예상을 해봐야하지 않을까?  
앞으로는 개인화가 될 소지가 있다. 하지만... 객체지향은 개인화가 아닌 집단화를 위해 만들어졌다.
개인화에 익숙해질때까지 아마 집단화 프로그램이 계속 만들어 질것 같다.

> 코드는 어디가지 않는다. 다만 흩어지고 조금더 이해하기 쉽게, 다른사람이 봐도 쉽게 만들뿐이다.
>> 다름사람과 같이 볼려면 같은 관점으로 볼수 있게 해야한다. 그게 팀별 패턴이 아닐까?
>> 그걸 패턴이라고 부르면서 그 패턴을 이해할 수 있어야한다. 
>> 한사람이 이해하는 패턴의 수정이 아닌, 여러사람이 하는 수정이 중요하다.

> 너무 오래토록 사용하는 패턴은 고착화를 시키기 쉽다. 계속 프로젝트 혹은 팀내에서 변화해야한다.
> 그렇다고 너무 많은 변화는 처음의 의도를 흩어 트린다. 같이 소통하고 이해하는 버릇을 들여야한다.  

> 업무 형태도 바뀌었다. 빠르게 만들고 빠르게 사라지는 프로그램이 만들어지기 시작한 것이다.(스타트업) 
> 느리게 만들어지는 프로그램, 점점 커져가는 시스템, 디펜던시가 심해서 혼자 돌아갈수 없는 프로그램..
>> 설계라는 요소는 점점 없어질것이고 관리라는 측면이 강조될것이다. 
>> 사람들은 빠른 리뷰와 리턴으로 프로그래밍 방식이 바뀔것이다.
>>> 템플릿이라는 요소는 더욱 커질것이다. 

> 하드웨어 스펙이 과거보다 빵빵하므로 하드웨어를 많이 투자하지만, 개발이 빠른것을 선호할 것이다.
>> 프로그램이 빠르고, 오류가 안나는 것은 사람들은 기본으로 여긴다. ㅋ... 말이 안되지만 말이다. 
>>> 사람들을 바꿀수는 없다. 인류의 진화는 어떻게 할수 없을정도로 느리니까말이다.

> 사람들은 시도했다. 탈 시스템화, 탈 DBMS 현재 그것의 최종본은 `마이크로 서비스`라는 형태로 나오고 있다.


> 탈 시스템화는 프론트엔드와 백엔드라는 형태로 되었고, 탈 DBMS는 실패하였으나 최소화하는 데는 성공하고있다. 
> 하지만 마이크로 서비스 만만치 않는 복잡성을 가지고 있다. 전체 시스템을 이해하기는 더욱 많은 공부가 필요해진것이다.
>> 문제점도 있는것 같다. 너무 많이 나뉘어 있어서, 공통화와 중복성을 체크할수 없다. 이것도 자동화해서 체크한다고는 하지만...   

 
> 코드가 업무와 섞여 있는 문제를 해결해야한다. 안그러면 업무를 아는 사람만이 수정을 할수 있게 되기 때문이다.

> 하지만 객체지향은 너무 형식에 억매이게 된다. 취지는 좋았는데... 그것도 사람이 하는 것이라고 그럴까? 
>> 또한 무거워지기 시작하고, 복잡해지기 시작했다. 물론 잘못된 방법이 어서 그렇겠지만 말이다.  

## 객체지향 살펴보기
### 객체지향 프로그래밍 정의

객체지향 참조(단어정의) : https://www.slideshare.net/plusjune/ss-46109239
객체지향 참조 : https://medium.com/@ehddnjs8989/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EA%B8%B0%EC%B4%88-oop-c50a7701223e
  - https://jeong-pro.tistory.com/95
객체지향 5원칙(SOLID) : https://dev-momo.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%99

* [객체지향이란](https://velog.io/@cyranocoding/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DOOP-Object-Oriented-Programming-%EA%B0%9C%EB%85%90-%EB%B0%8F-%ED%99%9C%EC%9A%A9-%EC%A0%95%EB%A6%AC-igjyooyc6c)
  - 컴퓨터 프로그램을 “객체(Object)"들의 모임으로 파악하고자 하는 프로그래밍의 패러다임
  - 프로그래밍에서 필요한 `데이터를 추상화`시켜 `상태와 행위`를 가진 `객체`를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법
  - `OOP의 가장 큰 특성` 중 하나가 바로 `코드의 재사용성과 상속의 개념`이다.
  - 비슷한 기능을 모아서 `응집력을 강화`, 클래스간 독립적으로 사용하게해서 `결합력을 약하게` : OOP의 경우 클래스에 하나의 문제 해결을 위해 데이터를 모아 놓은 객체를 활용한 프로그래밍을 지향하므로 `응집력을 강화`하며, 클래스 간에 독립적으로 디자인함으로써 `결합력을 약하게` 할 수 있다.
1. 장단점
  1. 장점
    1. 코드 재사용이 용이 : 남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있음.
    2. 유지보수가 쉬움 : 절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수혹은 메서드로 있기 때문에 해당 부분만 수정하면 됨. 
    3. 대형 프로젝트에 적합 : 클래스단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 분담하기 쉽다.
  2. 단점
    1. 처리속도가 상대적으로 느림
    2. 객체가 많으면 용량이 커질 수 있음
    3. 설계시 많은 시간과 노력이 필요

```
절차적 프로그램과의 다른 장단점
    1. 프로그램을 유연하고 변경이 용이하게 만든다.
      - 유연성 : 절차적 프로그래밍은 해당 프로그램가지고 다른것을 개발하려면 힘들다. 새로 만들어야 할 정도가 될수도 있다.
      - 변경성 : 비슷한 로직이 여기저기 흩어져 있다. 다 찾아 보려면 
    2. 프로그램의 개발과 보수를 간편하게 만든다.
      - 문서로 만드는 것이 가능하다.
      - UML등으로 소스를 좀더 잘 볼수 있게 되었다.
    3. 직관적인 코드 분석   
    
    위의 장점들을 관통하는 객체 지향 프로그래밍의 중요한 특성은 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향한다는 점이다.
```    
    
2. 특징
3. 키워드
  1. 클래스 + 인스턴스(객체)
  2. 추상화 : 공통의 속성이나 기능을 묶어 이름을 붙이는 것
    - 객체지향 관점에서 클래스를 정의하는 것
    - abstract 클래스, abstract 메서드와는 다른 이야기임
  3. 캡슐화(Encapsulation)
    - 목적 : 코드를 재수정 없이 재활용하는 것
    - 캡슐화를 통해 관련된 기능과 특성을 한 곳에 모으고 분류하기 때문에 재활용이 원활
    - 객체 지향 프로그래밍에서 기능과 특성의 모음을 "클래스"라는 "캡슐"에 분류해서 넣는것이 캡슐화다.
  4. 상속
    - 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것
  5. 다형성
    - 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석
    - 오버라이딩 : 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는것.
    - 오버로딩 : 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것.

* 캡슐화는 객체의 데이터를 외부에서 직접 접근하지 못하게 막고, 함수를 통해서만 조작이 가능하게 하는 작업이다.

* 추상화는 객체들이 가진 공통의 특성들을 파악하고 불필요한 특성들을 제거하는 과정을 말한다. 객체들이 가진 동작들을 기준으로 이용자들이 동작만 쉽게 구동할 수 있도록 한다. 몬스터의 예제에서 레벨업(levelUp) 메소드를 실행만 하면 level이라는 속성을 컨트롤 할 수 있었던 것처럼.
  이러한 추상화 과정을 통해 이용자들은 프로그래머가 만든 객체를 더 쉽게 사용할 수 있게 된다.
  추상화를 할 때 주의할 점은 속성 위주가 아닌 동작 위주로 정의하는 작업을 하는 것이다. 객체의 동작에 연관이 되지 않는 속성들은 결국은 불필요하다. 따라서 불필요한 속성들을 걸러내기 위해 동작을 먼저 정의하고 동작에 필요한 속성들을 정리하는 것이 좋다.

* +α 재사용성
  몬스터를 여러 마리 만들어야 한다. 각 몬스터들은 모두 같은 속성을 가지고 있다. 몬스터 객체를 이용하여 모든 몬스터들이 같은 속성과 메소드를 가질 수 있도록 만들 수 있다.
  `OOP의 가장 큰 특성` 중 하나가 바로 `코드의 재사용성과 상속의 개념`이다. 같은 객체를 여러 개 만들어야 하는 경우, 한 번 작성된 코드를 활용하여 동일한 객체를 만들 수 있다.
    
4. 특성
소프트웨어 공학에서 말하는,
- 응집력(cohesion) : 프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도. 프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있고, 지나치게 많은 일을 하지 않으면 그것을 응집력이 높다고 표현한다.
- 결합력(coupling) : 프로그램 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 얼마나 의존적인지를 나타내는 정도. 결합력이 낮다는 것은 한 요소가 다른 요소들과 관계를 크게 맺고 있지 않은 상태를 의미한다.

> 절자 지향 프로그래밍에서도 "라이브러리"를 통해서 남이 짜놓은 소스 코드를 가져와 사용할 수 있었다.
> 하지만 내 의도에 맞게 수정하게되면 다른 라이브러리가 되어 버전에 따라 동작하지 않을 수 있고 불필요한 코드의 수정작업을 해야한다는 것이다.
> 이런 문제를 해결하기 위해 [상속]이라는 것을 도입하였다.

### 객체지향 5대 원칙(SOILD 원칙)
> 상속보다는 인터페이스를 주로 사용
1. SRP(단일 책임 원칙) : 소프트웨어의 설계 부품(클래스, 함수 등)은 단 하나의 책임(기능)만을 가져야 한다.
   - 기능 단위로 설계(클래스와 함수를 정의)
2. OCP(개방-폐쇄 원칙) : 기존의 코드를 변경하지 않고(Closed) 기능을 수정하거나 추가할 수 있도록(Open) 설계해야 한다.
   - 인터페이스 사용
3. LSP(리스코프 치환 원칙) : 자식 클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다.
   - 공통기능은 상속사용  
4. DIP(의존 역전 원칙) : 의존 관계를 맺을 때, 변화하기 쉬운것 보단 변화하기 어려운 것에 의존해야 한다는 원칙이다. 
   - 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺는다는 것을 의미
   - 의존성 주입
5. ISP(인터페이스 분리 원칙) : 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다.
   - 인터페이스를 작게 쪼개자.(응집력 있는 인터페이스)

-  설계를 잘한 프로그램은 기본적으로 새로운 요구사항과 프로그램 변경에 영향을 받는 부분이 적다. 
   다시말해, 응집도는 높고 결합도는 낮은 프로그램을 뜻한다. 
   만약 한 클래스가 수행할 수 있는 기능, 즉 책임이 많아진다. 
   `책임이 많아지면 클래스 내부의 함수끼리 강한 결합을 발생`할 가능성이 높아진다. 
   이는 유지보수에 비용이 증가하게 되므로 따라서 `책임을 분리`시킬 필요가 있다.
   
- OCP에 만족하는 설계를 할 때 변경되는 것이 무엇인지에 초점을 맞춘다. 
  자주 변경되는 내용은 수정하기 쉽게 설계 하고, 
  변경되지 않아야 하는 것은 수정되는 내용에 영향을 받지 않게 하는 것이 포인트다. 
  이를 위해 자주 사용되는 문법이 인터페이스(Interface)이다.
  OCP를 만족한 설계는 `변경에 유연하므로 유지보수 비용을 줄여주고 코드의 가독성 또한 높아지는 효과`를 얻을 수 있다.
  
- 여기서 말하는 변화하기 쉬운것이란 구체적인 것을 말하고, 
  변화하기 어려운 것이란 추상적인 것을 말한다. 
  객체지향적인 관점에서 보자면 변화하기 쉬운것이란 구체화 된 클래스를 의미하고, 
  변화하기 어려운 것은 추상클래스나 인터페이스를 의미한다. 
  따라서 DIP를 만족한다는 것은 의존관계를 맺을 때, 
  `구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺는다는 것을 의미`한다.  
  
* 의존성 주입 : 인터페이스를 상속받아 구현한 클래스를 주고 받아서 쓰는 것
  
* 포스트 내용들은 위키피디아, JAVA 객체 지향 디자인 패턴(정인상/채홍석 지음, 한빛미디어) 서적을 참고하여 작성하였습니다. 
  - 출처: https://dev-momo.tistory.com/entry/SOLID-원칙 [Programming Note]   

> 프로그래머가 시간이 지나도 유지 보수와 확장이 쉬운 소프트웨어를 만드는데 이 원칙들을 적용할 수 있다. 

---

패턴의 분류
참조 자료 : https://gmlwjd9405.github.io/2018/07/06/design-pattern.html
> 소프트웨어를 설계할 때 `특정 맥락`에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 `재사용`할 할 수있는 훌륭한 `해결책`
디자인패턴의 필요성 : https://jwprogramming.tistory.com/67?category=680940


디자인 패턴 구조
1. 콘텍스트(context)
    문제가 발생하는 여어 상황을 기술한다. 즉, 패턴이 적용될 수 있는 상황을 나타낸다.
    경우에 따라서는 패턴이 유용하지 못한 상황을 나타내기도 한다.
2. 문제(problem)
    패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 기술한다.
    이때 여러 제약 사항과 영향력도 문제 해결을 위해 고려해야 한다.
3. 해결(solution)
    문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술한다.
    해결은 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿이다.
    디자인 패턴의 종류
    
GoF 디자인 패턴 분류
1. 생성 패턴(Creational) : 객체 생성을 할때 공통적으로 나타나는 문제 해결(컴파일 시점)
  - 싱글턴, 팩토리 메소드, 추상 팩토리, 프로토타입, 빌더 패턴
  - 의존성이 발견 되었을때 깔끔하게 쓰는 방법
3. 구조 패턴(Structural) : 자주 사용되는 객체들로 구성된 구조를 본다  
  - 데코레이터, 어댑터, 컴포지트, 퍼사드, 프록시, 브리지, 플라이웨이트
  - 서로 의존적인것을 조금이나마 심플하게 만들고자하는 의지?
2. 행위 패턴(Behavioral) : 코드의 동적변화를 구현할때 나타나는 공통된 문제 해결(동적 or 런타임 문제 해결)  
  - 스트래티지, 옵저버, 스테이트, 커맨드, 이터레이터, 템플릿 메소드, 인터프리터, 미디에이터, 역할 변경, 메멘토, 비지터
  - 객체들을 어떻게 연결 시킬것가에 더 중점을 두게 된다.
  - 객체들 사이의 행위나 알고리즘과 관련된 패턴으로 응용분야에 따라 행위가 다른 객체로 옮겨가거나 알고리즘이 대체되는 경우가 존재 할 때 사용한다.
  - 복잡한 코드가 보일때 분리하는데 많이 쓰지않을까?
클래스/객체로 패턴 분류
1. 클래스 패턴 (Class Pattern) : 클래스 사이의 관계가 상속을 통해서 어떤 식으로 정의되는지를 다룬다. 클래스 패턴은 컴파일시에 관계가 결정된다.
  - 템플릿 메소드, 팩토리 메소드, 어댑터, 인터프리터
2. 객체 패턴 (Object Patterns) : 객체 사이의 관계를 다루며, 객체 사이의 관계는 보통 구성을 통해서 정의된다. 객체 패턴에서는 일반적으로 실행 중에 관계가 생성되기 때문에 더 동적이고 유연하다.
  - 스트래티지, 옵저버, 데코레이터, 프록시, 컴포지트, 이터레이터, 스테이트, 추상 팩토리, 싱글턴, 비지터, 메멘토, 역할 사슬, 브리지, 미디에이터, 플라이웨이트, 프로토타입, 빌더

> GoF의 3가지 분류에는 대표(기본, 기반) 패턴이 있다. 생성에서는 팩토리 메서드, 구조에서는 어댑터, 행위에서는 전략 패턴이다.   

* 영어를 해석하면 각 패턴을 이해하기 쉬울때가 있다.  


* 사라져버린 디자인 패턴 : https://www.cisp.or.kr/archives/18726
  - 디자인패턴, 아키텍처, 프레임워크 차이
  
* uml 표기법
* gof 디지안 패턴 분류를 좀더 자세히 설명 : https://m.blog.naver.com/PostView.nhn?blogId=jaeminstar&logNo=220958990688&proxyReferer=https:%2F%2Fwww.google.com%2F
* 소프트웨어 디자인패턴 분류 : https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4#cite_note-PoEAA-4
  - 조금더 많은 패턴에 대해서 설명되어 있다.
* GOF의 디자인 패턴뿐 아니라 POSA와 J2EE까지 볼필요가 있다. 하지만... 우선은 GOF패턴을 위주로 보도록 하겠다.
 

## 디자인패턴 설명
* 디자인 패턴의 종류
> 디자인 패턴은 객체의 정의랑은 무관한것 같다. 이런이런 객체가 있는데... 공통된 기능, 공통된 사용법이 있을때 좀더 보기 좋게 하기위한 방법이다.

세상엔 수많은 종류의 디자인 패턴이 있다. 그 내용을 모두 찾아내서 정리하자면 끝이 없을 것이다. 그래서 해당 포스트는 공부를 하면서 지속적으로 내용을 추가하고 보완해갈 것이다.
- 팩토리 패턴 (factory pattern) : 생성할 구상 클래스를 서브클래스에서 결정한다.
- 추상 팩토리 패턴 (AbstractFactory pattern) : 클라이언트에서 구상 클래스를 지정하지 않으면서도 일군의 객체를 생성할 수 있도록 한다.
  - 다양한 구성 요소 별로 '객체의 집합'을 생성해야 할 때 유용
  - 응집이 필요한데 다양한 구성의 객체생성을 할때, 한꺼번에 몰리도록 할수 있다.
- 싱글턴 패턴 (singleton pattern) : 딱 한 객체만 생성되도록 제한한다
- 빌더 패턴 (builder pattern) : 제품을 여러 단계로 나눠서 만들 수 있도록 제품 생산 단계들을 캡슐화할 때
  - 만드는 방법과 객체 생성을 분리할때 사용한다, 디렉터(만드는 방법)와 빌드(객체) 두개가 나온다.
  - 여러객체를 썩어서 새로운 복합 객체를 만들때 사용
- 프로토타입 패턴 (prototype pattern) : 이미 있는 인스턴스를 복사해서 해서 생성하는 법(deep copy)

- 어댑터 패턴 (adaptor pattern) : 객체를 감싸서 다른 인터페이스를 제공한다. Wrapper
- 데코레이터 패턴 (decorator pattern) : 객체를 감싸서 새로운 행동을 제공한다. 새로운 행동을 추가할수 있는 구조를 만들어야 한다.
  - 특정 객체를 공유할수 있는 구조를 만든다. 그래서 값을 수정하면 그 객체에 반영되는 구조이다.
  - 요즘 싫어하는 HOC구조가 되겠다... callback과도 비슷하지만 다른구조.
- 컴포지트 패턴 (composite pattern) : 트리 구조 제공, 클라이언트에서 객체 컬렉션과 개발 객체를 똑같이 다룰 수 있도록 한다.
- 퍼사드 패턴 (facade pattern) : 일련의 클래스에 대해서 간단한 인터페이스를 제공한다.
  - Provide an unified interface to a set of interfaces in a subsystem
- 프록시 패턴 (proxy pattern) : 객체를 감싸서 그 객체에 대한 접근을 제어한다.
- 브리지 패턴 (bridge pattern) : 구현 뿐만 아니라 공통 기능(추상화)를 따로 정의한다.
  - 어찌보면 DI랑 비슷하다. 객체를 주입하지 않는가..
- 플라이웨이트 패턴 (flyweight pattern) : 어떤 클래스의 인스턴스 한 개만가지고 여러 개의 "가상 인스턴스"를 제공하고 싶을 때
  - 같은 객체를 여러개 사용할때 생성을 몇개 만들어서 제한한다. 객체 풀과 비슷하다.
  
- 스트래티지 패턴 (strategy pattern) : 교환 가능한 행동을 캡슐화하고 위임을 통해서 어떤 행동을 사용할지 결정한다.
  - 인터페이스를 활용하자.
- 옵저버 패턴 (observer pattern) : 상태가 변경되면 다른 객체들한테 연락을 돌릴 수 있게 한다.
  - 객체를 수정할수 있는 공통 인터페이스를 만들어야한다.
  - 값에 따른 모든 객체의 값 변경
- 스테이트 패턴 (state pattern) : 알고리즘의 개별 단계를 구현하는 방법을 서브클래스에서 결정한다.
  - 값에 따른 객체 변경, 스위치 on,off처럼 호출할때마다 객체에서 지정된 객체로 바꾼다.
- 커맨드 패턴 (command pattern) : 요청을 객체로 감싼다.
  - 콜백패턴과 비슷하다. 명령을 내리고 그 명령의 처리값을 받아서 실행할수 있는 객체를 만든다.
- 템플릿 메소드 패턴 (template method pattern) : 알고리즘의 개별 단계를 구현하는 방법을 서브클래스에서 결정한다.
  - 기본적인 골짜를 짜 놓고, 그것에 대한 값은 서브클래스에서 정한다.
  - 구체적인것이 생각안나고 스켈레톤 코드(예제성, 확인성)를 만들때 사용하면 좋을것 같다. 
- 이터레이터 패턴 (iterator pattern) : 컬렉션이어떤 식으로 구현되었는지 드러내진 않으면서도 컬렉션 내에 있는 모든 객체에 대해 반복 작업을 처리할 수 있게 한다.
- 역할 사슬 패턴 (chain of responsibility pattern) : 한 요청을 두 개 이상의 객체에서 처리하고 싶을 때
  - 처리범위가 정해져있을떄 쪼개는 방법, 각 처리범위에 따라서 처리 객체를 따로 분리한다.
  - 같은 기능을 가진것을 만들지만 상태에따라서 처리여부를 결정한다.
- 인터프리터 패턴 (Interpreter pattern) : 어떤 언어에 대한 인터프리터를 만들 때
  - 구문마다 해석하는 것을 따로 만든다.
- 미디에이터 패턴 (mediator pattern) : 서로 관련된 객체 사이의 복잡한 통신과 제어를 한 곳으로 집중시키고자 할 때
  - 좀더 복잡한 구조를 만든다.
  - 객체에서 다른 객체를 실행이 필요할 때 만든다.
  
- 메멘토 패턴 (memento pattern) : 백업, 트랜잭션, 객체를 이전의 상태로 복구시켜야 하는 경우
  - 상태를 기억하는 객체를 만들어서 그곳에 수정사항을 기억하게 한다.
  - 그러다가 복구가 필요한 시점에 복구를 한다.
  - 작은 트랜잭션이라고 할까? 아니다 복구만을 위한것이니까 트랜잭션하고는 다르다.
- 비지터 패턴 (visitor pattern) : 다양한 객체에 새로운 기능을 추가해야 하는데 캡슐화가 별로 중요하지 않은 경우
  - dispatch
  - 객체가 하는 일을 정의해 놓고, 해당 객체가 들어오면 그 객체의 일을 실행한다.  

메멘토와 비슷한.. 트랜잭션에 대한 패턴은 없네?

* 위 패턴에 대해서 (언제 어디서 누가 무엇을 왜 하는가)를 찾아야 하지 않을까?


### 생각이 어지러운 패턴
- 데코레이터 패턴 : 객체를 같이 써서 수정할떄마다 반영하는 구조
- 브리지 패턴 : 어디다가 써야할지 모르겠네, 이것도 거의 기본아닌가? 추상부와 구현부를 나누는게.. 일반적이지는 않구나.
  - 공통기능을 추상화하고 그것에 대한 구현부를 따로 해서 구현부를 넘겨주는 방식
  - 구현부를 받을수 있는 구조를 가져야한다.
- 옵저버 : 객체를 넣는다. 그러다가 수정되면 모든객체에 값을 수정해서 보낸다.
  - 객체를 수정할 수 있는 인터페이스가 있어야한다. 수정하는 방법은 각 객체가 행하고..
- 스테이트 : 스위치  
  - 상태를 모두 정의하는 객체가 있어야합니다. 
  - 옵저버 기능은 각 객체에 값을 집어 넣는것입니다. 요체는 상태에 대한 객체를 정의하고, 상황에 맞는 객체로 변경에서 넘겨주는 것입니다.
  - 객체를 언제 쓸지도 서브클래스에서 정합니다.
  - 


> 참... 비슷비슷하다..  
### 기타
- 컴파운드 패턴 (compound pattern) : 반복적으로 생길 수 있는 일반적인 문제를 해결하기 위한 용도로 두 개 이상의 패턴을 결합해서 사용한는 것

1. 생성 패턴
- 의존성 주입 : 프로그래밍이 사용 객체를 띄워놓고, 사용하는 객체에 주입하는 방식이다. 객체 풀과 같이 쓰이곤 한다. 
- 지연된 초기화 : 객체 생성을 사용할때 하는 방식, 레이지 로딩이라고도 한다. 사용할때 을 해서 프로그램 초기 실행 및 메모리 낭비를 줄이기 위한 조치이다. 
- 멀티턴 : ??
- 객체 풀 : 사용할 객체를 여러개 띄워놓고, 
- 자원의 획득은 초기화이다(Resource Acquisition Is Initialization, RAII) : ??	

2. 구조 패턴
- 프론트 컨트롤러
- 마커
- 모듈
- 트윈

3. 행동 패턴
블랙보드
널 객체
서번트
사양(Specification pattern)

4. 동시실행 패턴
- 액티브 오브젝트
- Balking
- 바인딩 속성
- 컴퓨트 커널
- 더블 체크 라킹(Double checked locking)
- 이벤트 기반 비동기
- 가디드 서스펜션(Guarded suspension)
- 조인
- 락
- 메시징 디자인 패턴 (MDP)
- 모니터 객체
- 반응자
- 읽기-쓰기 락
- 스케줄러
- 스레드 풀
- 스레드 특화 스토리지


* 출처: https://hyeonstorage.tistory.com/99 [개발이 하고 싶어요]

## 상황별 설명(언어별, 설계할때, 관리자 관점(시간측정), 기획자 관점, 개발할때, 의견교환을 위한 커뮤니티용,리팩터링할때)
이것을 통해서 얼마나 시간이 걸리는지 판단할수 있을까? 될까?
프로그램의 난이도, 프로그램의 개발 시간(물리적인), 만들어야 할 양 측정 

### GOF에서 표현식만 빌려오기
1. Factory Mothod : Factory.newInstance(), 서브클래스에서 생성하는 모든 곳
  - Factory란 단어자체도 많이 사용한다. new를 안쓰고 객체 생성
  - 싱글턴과 비슷하게 getInstance()라고 쓰기도 한다.
2. Builder : 값세팅이 복잡할때
    - 객체.builder(); 
    - 객체.setName("아이언맨").setAge(50).setMovie("아이언맨").builder();
3. Singleton : 객체.getInstance()
4. Prototype : 객체.clone(), deepCopy
5. Adaptor : 라이브러리와 외부라이브러리(C등의 다른 언어 라이브러리)등 현재것과 안맞는기능을 맞출때 사용     
6. Bridge : 추상클래스 추상클래스1 = new 추상클래스구현(new 구현개체())
  - 생성자에 값을 넣어서 보낸다.
  - DI와 비슷하고, Bean생성법과도 비스사고..
7. Command(명령), Chain of Respons
  - invoke(호출) , delegate(대리자)  
  - request, response(receiver)
  - 이벤트 처리 : event listener, callback(?)
  - on, handler : onClick, handlerSearch
    - onClick로 클릭 사람들이 누르면 handlerClick라는 함수를 만들어서 처리한다.
8. Decorator : 구현객체1(구현객체2(구현객체3(구현객체4())))
9. Template Method : 스켈레톤(뼈대), 처리 방법은 내가 만든다. 너는 각 처리방법을 만들기나해
  - 어쩌면 공장구조와 비슷할지도....? 
10.Interpreter : 객체.parse, 객체.parse기능명 

* 객체를 넘기는 두가지 방법
  1. 인터페이스를 만들어서 리턴값을 통일 시켜서 사용한다.
  2. 생성할때 객체를 생성 파라미터에 넣는다.
     
```java
public class Support {
    public void use(){
        Creator create = new Create1();
        Product product = create1.newInstance();    
    }
    
    public vlid use1(){
        //내부에서 Builder를 가져가서 처리한다.
        Create create = new Create(new Builder());
    }    
}    
```     

### 객체유형
1. 단일 객체
  - 싱글턴
  - 팩토리 메서드 패턴
2. 복합객체를 다룰때
  - Abstract Factory : 복합객체를 한군데서 여러개 만든다.
  - Builder : 복합객체를 나누어서 한군데서 나누어서 만든다.
3. (객체 or 값) 공유(자료구조)
  - 싱글턴 : 데이터(상태)를 공유한다. 하나를 유지
  - 콤포짓 : 리스트 형식으로 저장한다.
  - 데코레이터 : 목적객체를 만들어서 목적객체의 공유하고, 상태를 변화시켜 사용한다.
  - 플라이웨이트 : 목적객체를 키값으로 저장한다. 그리고 필요할때 목적객체를 가져온다.
  - 메멘토 : 사용했을때의 값(or 객체)을 저장한뒤에 나중에 호출한다.
  - 옵저버 : 특정객체에 목적객체를 리스트로 가지고 있는다. 각 객체의 수정메서드를 호출하도록 한다.
  - 스테이트 : 목적 객체에서 공유 객체를 바꾼다.  
4. 재귀 : 
  - 콤포짓 : 객체에 객체를 담을수 있는 포함구조를 만든다.
  - 데코레이터 : 상위객체 호출을 통한 재귀 실행, super 활용
  - 인터프리터 : 
5. 기본 유형
  - 팩토리 메서드 패턴
  - 브릿지 : 
  - 컴포짓 : 객체 포함구조를 만드는 기본 구조
  
  - 스트레티지(전략패턴) : 인터페이스 사용의 기본
  - 이터레이터 : 반복문의 기본구조 
  
6. 독립적
  - 프로토타입 : 
  - 싱글턴
  - 아답터
  - 프록시
     
  - 커맨드
  - 인터프리터 
  - 템플레이트 메서드 : 뼈대, 스켈레톤
7. 상태처리 : 상태에 따라서 처리자를 결정한다. if문 대용이 될수가 있다.
  - 체인오브리스폰 : 처리할수 있는 상태이면 처리하고 아니면 다음 객체에 넘긴다.
  - 인터프리터 : 자신이 처리할수 있는 값이 포함되어 있으면 처리한다.
  - 미디에이트 : 사용하는 객체에 따라서 나누어 놓은것 
  
8. 준비된자(1:1)
  - 커맨드 : 명령에대한 처리자가 있어야한다.
  - 비지터 
9 통합
  - 앱스트랙트 팩토리 : 복합적인 목적객체를 만드는 방법을 모아둔다.
    - 무엇무엇을 만드는지 알수 있다. 
  - 파사드 : 포함된 객체들을 통합해서 사용하는 법을 알려준다.
  - 미디에이터 : 객체에 각 목적객체 사용방법을 정의한다. 목적객체의 사용하는 법을 한곳에 모은다.
  - 비지터 : 목적객체에서 특정객체의 메서드를 호출하고, 특정객체는 다시 목적 객체의 값을 호출한다. 
     - 어렵네... 흠 무엇이 어려울까?
   
10. 내부 호출을 이용
  - 미디에이터 : 통일된 메서드 제공
  - 스테이트 : 각 목적객체에서 다음 객체를 지정해서 객체(값)를 바꿔준다. 스위치

11. double-dispatch : 호출한것에서 역으로 목적객체를 호출한다. 객체 주입에서 많이 사용한다.
  - 비지터 :
  - 미디에이터
  - 옵저버 :  
  
> 더블 디스패치식으로 되어있는건 이해하는 난이도가 있다.

12. 상위객체(or 주입객체) 메서드 호출 : super사용
  - 컴포짓 
  - 데코레이터 : 값을 상위 객체에 전달한다. 
  - 체인오브리스폰 : 값들 다른 객체에 전달한다.
  - 인터프리터 : 
  - 미디에이터 : 
  
0000. GOF 
  - 생성패턴 : 객체를 리턴하기 위한 목적
  - 구조패턴 : 체계적인 구조를 만드는 목적, 값을 리턴한다.
  - 행동패턴 : 처리의 복잡성을 나누어서 가지기 위한 목적
    - 체인오브리스폰 : 요청을 분석하여서 자신이 처리할수 있으면 처리하고 아니면 넘기는 구조 
      - 자동처리장치?


### 정리중
생성 패턴은 객체의 특성을 나타내게 되는것 아닐까?
싱글턴의 경우 값 공유 할곳이 많을때,
프로토 타입은 중간에 독립적으로 계산이 필요할때 사용
빌더는 넣어야하는 값, 의존성이 많은 객체
팩토리 메서드는... 기본이다. 모두 다~~ 서브 클래스에 맏기게 된다.
  - 생성이 볶잡할때 정리하려고 하면 기본적으로 4가지의 클래스를 정의해야한다.
  - 만드는 방법의 추상화, 추상화를 구현한 클래스
  - 실제 객체의 추상화, 추상화를 구현한 클래스


와우 생성하는데 모가 이렇게 복잡해.....? 줄여보자. 줄이는 방법은?
  - 싱글턴 : 그냥 전체 공유해.. 값... 한군데 관리를 하자고, 계속 값을 넘기지 말고!
    - 기존에 사용하는 코드가 있을때 이것으로 다 바꿔야한다.
  - 프로토타입 : 새로 만들필요 있어? 복사해. 대신.. 기존 객체에 영향을 주면 안된다~ 따로 객체여야해! 값은 가져오지만말이야..
  - 팩터리 메서드 : 결정하는 다른애를 써보자... 그리고 생성 방법도 통일해! 좀 알아먹게 요약하자
  - 빌더 : 생성하는데 넣어야 하는 값이 왜이렇게 많아?
    - 체이닝(.)으로 상태값 전달하기, 디렉터에서 생성하고, 제품도 거기서 결정
  - 추상팩터리 : 만드는 방법은 통일해 줄께, 대신 여러 가지 객체가 가능해야해!

> 근데 말이야... 소스가 간단해진게 맞나? 이해하기가 힘들어 지는데?
> 빌더 추상팩토리는 팩토리 메서드가 기본으로 깔려있다.

> 캡슐화는 내부에서 무엇을 하고 있는지 알수 없다. 내부를 고쳐야할때는 어떻게 해야하는가?
> 코드가 이해가 될까? 쉽게하자고 하는 요즘에는 더 어렵게 만드는 것일수도 있다. HOC처럼 
>> 이렇게 안보이게 하는 캡슐화가 과연 좋은것인가?


### 자바에서의 패턴(구현되어 있는 것 포함)
  
* [디자인 패턴-위키피디아](https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4#cite_note-PoEAA-4)
* [GOF-디자인패턴](http://www.w3sdesign.com/#gf)
* [디자인패턴정리](https://realzero0.github.io/study/2017/06/12/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EC%A0%95%EB%A6%AC.html)
* [디자인패턴정리-첨부파일](https://gone-sw.tistory.com/4)

---

기타 다시 보기 : 머리로만 알고있는것을 말로 풀이할수 있다.
[신입-개발자 면접 기초](https://jeong-pro.tistory.com/category/%EC%8B%A0%EC%9E%85%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EA%B8%B0%EC%B4%88)

* 내가 정리한 내역 : https://docs.google.com/spreadsheet/ccc?pli=1&key=0AiKv27aORwSJdHdvX3h3ZWVodUEtNUtNSmc4SV9ZdEE&hl=ko#gid=0
* 다시 자바로 따라해보기를 하면서 익혀보자.

> 이해와 실행은 별개이다.. 실행단계까지 가보려면.. 계속 해보는 수밖에