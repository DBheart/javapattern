GOF 디자인 패턴은 잘만들었다. 그것을 통해서 앞으로 가야할바를 명시해볼예정이다.
기초가 잘되어야지 뒤가 있듯이... 과거를 살펴보고 현재를 보고 미래를 살펴보자.

프로그램에 대해서 살펴보고, 디자인패턴의 근간인 객체지향에 대해서 살펴보고, 디자인패턴을 공부할것이다.
디자인 패턴에서 어떻게 프로그램을 구성할것인지 생각할수 있는 근간을 마련해볼것이다.

디자인 패턴은 하나의 소통언어가 될수 있지 않을까한다. 그 프로젝트, 그 팀에서 어떻게 만들것인가의 최소 소통방법이 될수 있을것 같다.


## 프로그램 분류
1. 절차적 프로그래밍
1.2 구조적 프로그래밍(???)
1.5 WEB의 발전, 세션단위(stateless)
2. 객체지향적 프로그래밍\
2.5 데이터베이스 시스템(대용량 처리를 위한.. : 트랜잭션 이슈 처리)
3. 비동기 프로그래밍
4. 함수형 프로그래밍

절차적 프로그래밍은 작은 단위의 프로그램을 할때 좋다. 
하지만 점점 사람들은 많이 사용하게 되었고 프로그램들을 묶은 시스템 개념으로 만들게 되었다.
큰 시스템은 설계를 위한 형식이 필요하게 되었고, 그것을 만족한것이 객체지향 프로그래밍이었다.
하지만 객체지향에 적응 하지 못했던, 기존의 개발자들이 많아 졌다. 
그래서 객체지향의 대표주자(?) 자바가 한참 유행한떄에는 데이터베이스 시스템의 부흥기가 왔다.
제일 중요한 데이터를 다루는 것을 절차지향적인 SQL, DBMS 펑션, 프로시져, DBMS 패키지, 심지어는 SAP에 넘기게 되었다.
하지만 세월은 또 변했다. 사람들은 객체지향에 익숙해졌지만, 이번에는 시스템이 문제였다.
지금 시도되고 있는 함수형 프로그래밍(하지만 시도되고 있다기에는.. 나온지 벌써 10년은 되었다)
사람들은 적응하고 있는중이다. 

절차적 프로그래밍이 그랬듯이 언어는 함수형 프로그래밍도 객체지향적으로 사람들은 짤것이다. 
함수형 프로그래밍이 많이 쓰는 그날이 오기까지말이다.. 

앞으로 객체지향에 익숙한 사람들에게 함수형을 어떻게 더욱 익숙하게 할것인가와 어떻게 변해갈지 예상을 해봐야하지 않을까?  

> 업무 형태도 바뀌었다. 빠르게 만들고 빠르게 사라지는 프로그램이 만들어지기 시작한 것이다.(스타트업) 
> 느리게 만들어지는 프로그램, 점점 커져가는 시스템, 디펜던시가 심해서 혼자 돌아갈수 없는 프로그램..
>> 설계라는 요소는 점점 없어질것이고 관리라는 측면이 강조될것이다. 
>> 사람들은 빠른 리뷰와 리턴으로 프로그래밍 방식이 바뀔것이다.
>>> 템플릿이라는 요소는 더욱 커질것이다. 

> 하드웨어 스펙이 과거보다 빵빵하므로 하드웨어를 많이 투자하지만, 개발이 빠른것을 선호할 것이다.
>> 프로그램이 빠르고, 오류가 안나는 것은 사람들은 기본으로 여긴다. ㅋ... 말이 안되지만 말이다. 
>>> 사람들을 바꿀수는 없다. 인류의 진화는 어떻게 할수 없을정도로 느리니까말이다.

> 사람들은 시도했다. 탈 시스템화, 탈 DBMS 현재 그것의 최종본은 `마이크로 서비스`라는 형태로 나오고 있다.


> 탈 시스템화는 프론트엔드와 백엔드라는 형태로 되었고, 탈 DBMS는 실패하였으나 최소화하는 데는 성공하고있다. 
> 하지만 마이크로 서비스 만만치 않는 복잡성을 가지고 있다. 전체 시스템을 이해하기는 더욱 많은 공부가 필요해진것이다.
>> 문제점도 있는것 같다. 너무 많이 나뉘어 있어서, 공통화와 중복성을 체크할수 없다. 이것도 자동화해서 체크한다고는 하지만...   

 
> 코드가 업무와 섞여 있는 문제를 해결해야한다. 안그러면 업무를 아는 사람만이 수정을 할수 있게 되기 때문이다.

> 하지만 객체지향은 너무 형식에 억매이게 된다. 취지는 좋았는데... 그것도 사람이 하는 것이라고 그럴까? 
>> 또한 무거워지기 시작하고, 복잡해지기 시작했다. 물론 잘못된 방법이 어서 그렇겠지만 말이다.  

## 객체지향 살펴보기
### 객체지향 프로그래밍 정의

객체지향 참조(단어정의) : https://www.slideshare.net/plusjune/ss-46109239
객체지향 참조 : https://medium.com/@ehddnjs8989/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EA%B8%B0%EC%B4%88-oop-c50a7701223e
  - https://jeong-pro.tistory.com/95
객체지향 5원칙(SOLID) : https://dev-momo.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%99

* [객체지향이란](https://velog.io/@cyranocoding/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DOOP-Object-Oriented-Programming-%EA%B0%9C%EB%85%90-%EB%B0%8F-%ED%99%9C%EC%9A%A9-%EC%A0%95%EB%A6%AC-igjyooyc6c)
  - 컴퓨터 프로그램을 “객체(Object)"들의 모임으로 파악하고자 하는 프로그래밍의 패러다임
  - 프로그래밍에서 필요한 `데이터를 추상화`시켜 `상태와 행위`를 가진 `객체`를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법
  - `OOP의 가장 큰 특성` 중 하나가 바로 `코드의 재사용성과 상속의 개념`이다.
  - 비슷한 기능을 모아서 `응집력을 강화`, 클래스간 독립적으로 사용하게해서 `결합력을 약하게` : OOP의 경우 클래스에 하나의 문제 해결을 위해 데이터를 모아 놓은 객체를 활용한 프로그래밍을 지향하므로 `응집력을 강화`하며, 클래스 간에 독립적으로 디자인함으로써 `결합력을 약하게` 할 수 있다.
1. 장단점
  1. 장점
    1. 코드 재사용이 용이 : 남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있음.
    2. 유지보수가 쉬움 : 절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수혹은 메서드로 있기 때문에 해당 부분만 수정하면 됨. 
    3. 대형 프로젝트에 적합 : 클래스단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 분담하기 쉽다.
  2. 단점
    1. 처리속도가 상대적으로 느림
    2. 객체가 많으면 용량이 커질 수 있음
    3. 설계시 많은 시간과 노력이 필요

```
절차적 프로그램과의 다른 장단점
    1. 프로그램을 유연하고 변경이 용이하게 만든다.
      - 유연성 : 절차적 프로그래밍은 해당 프로그램가지고 다른것을 개발하려면 힘들다. 새로 만들어야 할 정도가 될수도 있다.
      - 변경성 : 비슷한 로직이 여기저기 흩어져 있다. 다 찾아 보려면 
    2. 프로그램의 개발과 보수를 간편하게 만든다.
      - 문서로 만드는 것이 가능하다.
      - UML등으로 소스를 좀더 잘 볼수 있게 되었다.
    3. 직관적인 코드 분석   
    
    위의 장점들을 관통하는 객체 지향 프로그래밍의 중요한 특성은 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향한다는 점이다.
```    
    
2. 특징
3. 키워드
  1. 클래스 + 인스턴스(객체)
  2. 추상화 : 공통의 속성이나 기능을 묶어 이름을 붙이는 것
    - 객체지향 관점에서 클래스를 정의하는 것
    - abstract 클래스, abstract 메서드와는 다른 이야기임
  3. 캡슐화(Encapsulation)
    - 목적 : 코드를 재수정 없이 재활용하는 것
    - 캡슐화를 통해 관련된 기능과 특성을 한 곳에 모으고 분류하기 때문에 재활용이 원활
    - 객체 지향 프로그래밍에서 기능과 특성의 모음을 "클래스"라는 "캡슐"에 분류해서 넣는것이 캡슐화다.
  4. 상속
    - 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것
  5. 다형성
    - 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석
    - 오버라이딩 : 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는것.
    - 오버로딩 : 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것.

* 캡슐화는 객체의 데이터를 외부에서 직접 접근하지 못하게 막고, 함수를 통해서만 조작이 가능하게 하는 작업이다.

* 추상화는 객체들이 가진 공통의 특성들을 파악하고 불필요한 특성들을 제거하는 과정을 말한다. 객체들이 가진 동작들을 기준으로 이용자들이 동작만 쉽게 구동할 수 있도록 한다. 몬스터의 예제에서 레벨업(levelUp) 메소드를 실행만 하면 level이라는 속성을 컨트롤 할 수 있었던 것처럼.
  이러한 추상화 과정을 통해 이용자들은 프로그래머가 만든 객체를 더 쉽게 사용할 수 있게 된다.
  추상화를 할 때 주의할 점은 속성 위주가 아닌 동작 위주로 정의하는 작업을 하는 것이다. 객체의 동작에 연관이 되지 않는 속성들은 결국은 불필요하다. 따라서 불필요한 속성들을 걸러내기 위해 동작을 먼저 정의하고 동작에 필요한 속성들을 정리하는 것이 좋다.

* +α 재사용성
  몬스터를 여러 마리 만들어야 한다. 각 몬스터들은 모두 같은 속성을 가지고 있다. 몬스터 객체를 이용하여 모든 몬스터들이 같은 속성과 메소드를 가질 수 있도록 만들 수 있다.
  `OOP의 가장 큰 특성` 중 하나가 바로 `코드의 재사용성과 상속의 개념`이다. 같은 객체를 여러 개 만들어야 하는 경우, 한 번 작성된 코드를 활용하여 동일한 객체를 만들 수 있다.
    
4. 특성
소프트웨어 공학에서 말하는,
- 응집력(cohesion) : 프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도. 프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있고, 지나치게 많은 일을 하지 않으면 그것을 응집력이 높다고 표현한다.
- 결합력(coupling) : 프로그램 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 얼마나 의존적인지를 나타내는 정도. 결합력이 낮다는 것은 한 요소가 다른 요소들과 관계를 크게 맺고 있지 않은 상태를 의미한다.

> 절자 지향 프로그래밍에서도 "라이브러리"를 통해서 남이 짜놓은 소스 코드를 가져와 사용할 수 있었다.
> 하지만 내 의도에 맞게 수정하게되면 다른 라이브러리가 되어 버전에 따라 동작하지 않을 수 있고 불필요한 코드의 수정작업을 해야한다는 것이다.
> 이런 문제를 해결하기 위해 [상속]이라는 것을 도입하였다.

### 객체지향 5대 원칙(SOILD 원칙)
> 상속보다는 인터페이스를 주로 사용
1. SRP(단일 책임 원칙) : 소프트웨어의 설계 부품(클래스, 함수 등)은 단 하나의 책임(기능)만을 가져야 한다.
   - 기능 단위로 설계(클래스와 함수를 정의)
2. OCP(개방-폐쇄 원칙) : 기존의 코드를 변경하지 않고(Closed) 기능을 수정하거나 추가할 수 있도록(Open) 설계해야 한다.
   - 인터페이스 사용
3. LSP(리스코프 치환 원칙) : 자식 클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다.
   - 공통기능은 상속사용  
4. DIP(의존 역전 원칙) : 의존 관계를 맺을 때, 변화하기 쉬운것 보단 변화하기 어려운 것에 의존해야 한다는 원칙이다. 
   - 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺는다는 것을 의미
   - 의존성 주입
5. ISP(인터페이스 분리 원칙) : 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다.
   - 인터페이스를 작게 쪼개자.(응집력 있는 인터페이스)

-  설계를 잘한 프로그램은 기본적으로 새로운 요구사항과 프로그램 변경에 영향을 받는 부분이 적다. 
   다시말해, 응집도는 높고 결합도는 낮은 프로그램을 뜻한다. 
   만약 한 클래스가 수행할 수 있는 기능, 즉 책임이 많아진다. 
   `책임이 많아지면 클래스 내부의 함수끼리 강한 결합을 발생`할 가능성이 높아진다. 
   이는 유지보수에 비용이 증가하게 되므로 따라서 `책임을 분리`시킬 필요가 있다.
   
- OCP에 만족하는 설계를 할 때 변경되는 것이 무엇인지에 초점을 맞춘다. 
  자주 변경되는 내용은 수정하기 쉽게 설계 하고, 
  변경되지 않아야 하는 것은 수정되는 내용에 영향을 받지 않게 하는 것이 포인트다. 
  이를 위해 자주 사용되는 문법이 인터페이스(Interface)이다.
  OCP를 만족한 설계는 `변경에 유연하므로 유지보수 비용을 줄여주고 코드의 가독성 또한 높아지는 효과`를 얻을 수 있다.
  
- 여기서 말하는 변화하기 쉬운것이란 구체적인 것을 말하고, 
  변화하기 어려운 것이란 추상적인 것을 말한다. 
  객체지향적인 관점에서 보자면 변화하기 쉬운것이란 구체화 된 클래스를 의미하고, 
  변화하기 어려운 것은 추상클래스나 인터페이스를 의미한다. 
  따라서 DIP를 만족한다는 것은 의존관계를 맺을 때, 
  `구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺는다는 것을 의미`한다.  
  
* 의존성 주입 : 인터페이스를 상속받아 구현한 클래스를 주고 받아서 쓰는 것
  
* 포스트 내용들은 위키피디아, JAVA 객체 지향 디자인 패턴(정인상/채홍석 지음, 한빛미디어) 서적을 참고하여 작성하였습니다. 
  - 출처: https://dev-momo.tistory.com/entry/SOLID-원칙 [Programming Note]   

> 프로그래머가 시간이 지나도 유지 보수와 확장이 쉬운 소프트웨어를 만드는데 이 원칙들을 적용할 수 있다. 

---

패턴의 분류
참조 자료 : https://gmlwjd9405.github.io/2018/07/06/design-pattern.html
> 소프트웨어를 설계할 때 `특정 맥락`에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 `재사용`할 할 수있는 훌륭한 `해결책`

디자인 패턴 구조
1. 콘텍스트(context)
    문제가 발생하는 여어 상황을 기술한다. 즉, 패턴이 적용될 수 있는 상황을 나타낸다.
    경우에 따라서는 패턴이 유용하지 못한 상황을 나타내기도 한다.
2. 문제(problem)
    패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 기술한다.
    이때 여러 제약 사항과 영향력도 문제 해결을 위해 고려해야 한다.
3. 해결(solution)
    문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술한다.
    해결은 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿이다.
    디자인 패턴의 종류
    
GoF 디자인 패턴 분류
1. 생성 패턴(Creational) : 객체 생성을 할때 공통적으로 나타나는 문제 해결
  - 싱글턴, 팩토리 메소드, 추상 팩토리, 프로토타입, 빌더 패턴
3. 구조 패턴(Structural) : 자주 사용되는 객체들로 구성된 구조를 본다  
  - 데코레이터, 어댑터, 컴포지트, 퍼사드, 프록시, 브리지, 플라이웨이트
2. 행위 패턴(Behavioral) : 코드의 동적변화를 구현할때 나타나는 공통된 문제 해결(동적 or 런타임 문제 해결)  
  - 스트래티지, 옵저버, 스테이트, 커맨드, 이터레이터, 템플릿 메소드, 인터프리터, 미디에이터, 역할 변경, 메멘토, 비지터
  - 객체들을 어떻게 연결 시킬것가에 더 중점을 두게 된다.
  - 객체들 사이의 행위나 알고리즘과 관련된 패턴으로 응용분야에 따라 행위가 다른 객체로 옮겨가거나 알고리즘이 대체되는 경우가 존재 할 때 사용한다.

클래스/객체로 패턴 분류
1. 클래스 패턴 (Class Pattern) : 클래스 사이의 관계가 상속을 통해서 어떤 식으로 정의되는지를 다룬다. 클래스 패턴은 컴파일시에 관계가 결정된다.
  - 템플릿 메소드, 팩토리 메소드, 어댑터, 인터프리터
2. 객체 패턴 (Object Patterns) : 객체 사이의 관계를 다루며, 객체 사이의 관계는 보통 구성을 통해서 정의된다. 객체 패턴에서는 일반적으로 실행 중에 관계가 생성되기 때문에 더 동적이고 유연하다.
  - 스트래티지, 옵저버, 데코레이터, 프록시, 컴포지트, 이터레이터, 스테이트, 추상 팩토리, 싱글턴, 비지터, 메멘토, 역할 사슬, 브리지, 미디에이터, 플라이웨이트, 프로토타입, 빌더

> GoF의 3가지 분류에는 대표(기본, 기반) 패턴이 있다. 생성에서는 팩토리 메서드, 구조에서는 어댑터, 행위에서는 전략 패턴이다.   

* 영어를 해석하면 각 패턴을 이해하기 쉬울때가 있다.  


* 사라져버린 디자인 패턴 : https://www.cisp.or.kr/archives/18726
  - 디자인패턴, 아키텍처, 프레임워크 차이
  
* uml 표기법
* gof 디지안 패턴 분류를 좀더 자세히 설명 : https://m.blog.naver.com/PostView.nhn?blogId=jaeminstar&logNo=220958990688&proxyReferer=https:%2F%2Fwww.google.com%2F
* 소프트웨어 디자인패턴 분류 : https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4#cite_note-PoEAA-4
  - 조금더 많은 패턴에 대해서 설명되어 있다.
* GOF의 디자인 패턴뿐 아니라 POSA와 J2EE까지 볼필요가 있다. 하지만... 우선은 GOF패턴을 위주로 보도록 하겠다.
 

## 디자인패턴 설명
* 디자인 패턴의 종류

세상엔 수많은 종류의 디자인 패턴이 있다. 그 내용을 모두 찾아내서 정리하자면 끝이 없을 것이다. 그래서 해당 포스트는 공부를 하면서 지속적으로 내용을 추가하고 보완해갈 것이다.
- 팩토리 패턴 (factory pattern) : 생성할 구상 클래스를 서브클래스에서 결정한다.
- 추상 팩토리 패턴 (AbstractFactory pattern) : 클라이언트에서 구상 클래스를 지정하지 않으면서도 일군의 객체를 생성할 수 있도록 한다.
  - 다양한 구성 요소 별로 '객체의 집합'을 생성해야 할 때 유용
  - 응집이 필요한데 다양한 구성의 객체생성을 할때, 한꺼번에 몰리도록 할수 있다.
- 싱글턴 패턴 (singleton pattern) : 딱 한 객체만 생성되도록 제한한다
- 빌더 패턴 (builder pattern) : 제품을 여러 단계로 나눠서 만들 수 있도록 제품 생산 단계들을 캡슐화할 때
  - 만드는 방법과 객체 생성을 분리할때 사용한다, 디렉터(만드는 방법)와 빌드(객체) 두개가 나온다.
- 프로토타입 패턴 (prototype pattern) : 이미 있는 인스턴스를 복사해서 해서 생성하는 법(deep copy)

- 어댑터 패턴 (adaptor pattern) : 객체를 감싸서 다른 인터페이스를 제공한다. Wrapper
- 데코레이터 패턴 (decorator pattern) : 객체를 감싸서 새로운 행동을 제공한다. 새로운 행동을 추가할수 있는 구조를 만들어야 한다.
- 컴포지트 패턴 (composite pattern) : 트리 구조 제공, 클라이언트에서 객체 컬렉션과 개발 객체를 똑같이 다룰 수 있도록 한다.
- 퍼사드 패턴 (facade pattern) : 일련의 클래스에 대해서 간단한 인터페이스를 제공한다.
- 프록시 패턴 (proxy pattern) : 객체를 감싸서 그 객체에 대한 접근을 제어한다.
- 브리지 패턴 (bridge pattern) : 구현 뿐만 아니라 추상화된 부분까지 변경시켜야 하는 경우
  - 기능이 수시로 바뀔수 있도록 구조를 만든다. 그래도 한계는 있겠지...
- 플라이웨이트 패턴 (flyweight pattern) : 어떤 클래스의 인스턴스 한 개만가지고 여러 개의 "가상 인스턴스"를 제공하고 싶을 때
  - 같은 객체를 여러개 사용할때 생성을 몇개 만들어서 제한한다. 객체 풀과 비슷하다.
  
- 스트래티지 패턴 (strategy pattern) : 교환 가능한 행동을 캡슐화하고 위임을 통해서 어떤 행동을 사용할지 결정한다.
- 옵저버 패턴 (observer pattern) : 상태가 변경되면 다른 객체들한테 연락을 돌릴 수 있게 한다.
- 스테이트 패턴 (state pattern) : 알고리즘의 개별 단계를 구현하는 방법을 서브클래스에서 결정한다.
- 커맨드 패턴 (command pattern) : 요청을 객체로 감싼다.
- 템플릿 메소드 패턴 (template method pattern) : 알고리즘의 개별 단계를 구현하는 방법을 서브클래스에서 결정한다.
- 이터레이터 패턴 (iterator pattern) : 컬렉션이어떤 식으로 구현되었는지 드러내진 않으면서도 컬렉션 내에 있는 모든 객체에 대해 반복 작업을 처리할 수 있게 한다.
- 역할 사슬 패턴 (chain of responsibility pattern) : 한 요청을 두 개 이상의 객체에서 처리하고 싶을 때
- 인터프리터 패턴 (Interpreter pattern) : 어떤 언어에 대한 인터프리터를 만들 때
- 미디에이터 패턴 (mediator pattern) : 서로 관련된 객체 사이의 복잡한 통신과 제어를 한 곳으로 집중시키고자 할 때
- 메멘토 패턴 (memento pattern) : 백업, 트랜잭션, 객체를 이전의 상태로 복구시켜야 하는 경우
- 비지터 패턴 (visitor pattern) : 다양한 객체에 새로운 기능을 추가해야 하는데 캡슐화가 별로 중요하지 않은 경우

### 생각이 어지러운 패턴
- 추상 팩토리 패턴
- 옵저버 패턴
- 브리지 패턴 
- 데코레이터 패턴

### 기타
- 컴파운드 패턴 (compound pattern) : 반복적으로 생길 수 있는 일반적인 문제를 해결하기 위한 용도로 두 개 이상의 패턴을 결합해서 사용한는 것

1. 생성 패턴
- 의존성 주입 : 프로그래밍이 사용 객체를 띄워놓고, 사용하는 객체에 주입하는 방식이다. 객체 풀과 같이 쓰이곤 한다. 
- 지연된 초기화 : 객체 생성을 사용할때 하는 방식, 레이지 로딩이라고도 한다. 사용할때 을 해서 프로그램 초기 실행 및 메모리 낭비를 줄이기 위한 조치이다. 
- 멀티턴 : ??
- 객체 풀 : 사용할 객체를 여러개 띄워놓고, 
- 자원의 획득은 초기화이다(Resource Acquisition Is Initialization, RAII) : ??	

2. 구조 패턴
- 프론트 컨트롤러
- 마커
- 모듈
- 트윈

3. 행동 패턴
블랙보드
널 객체
서번트
사양(Specification pattern)

4. 동시실행 패턴
- 액티브 오브젝트
- Balking
- 바인딩 속성
- 컴퓨트 커널
- 더블 체크 라킹(Double checked locking)
- 이벤트 기반 비동기
- 가디드 서스펜션(Guarded suspension)
- 조인
- 락
- 메시징 디자인 패턴 (MDP)
- 모니터 객체
- 반응자
- 읽기-쓰기 락
- 스케줄러
- 스레드 풀
- 스레드 특화 스토리지


* 출처: https://hyeonstorage.tistory.com/99 [개발이 하고 싶어요]

## 상황별 설명(언어별, 설계할때, 관리자 관점(시간측정), 기획자 관점, 개발할때, 의견교환을 위한 커뮤니티용)
이것을 통해서 얼마나 시간이 걸리는지 판단할수 있을까? 될까?
프로그램의 난이도, 프로그램의 개발 시간(물리적인), 만들어야 할 양 측정 

### 자바에서의 패턴(구현되어 있는 것 포함)
  
  
---

기타 다시 보기 : 머리로만 알고있는것을 말로 풀이할수 있다.
[신입-개발자 면접 기초](https://jeong-pro.tistory.com/category/%EC%8B%A0%EC%9E%85%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%A9%B4%EC%A0%91%20%EA%B8%B0%EC%B4%88)

* 내가 정리한 내역 : https://docs.google.com/spreadsheet/ccc?pli=1&key=0AiKv27aORwSJdHdvX3h3ZWVodUEtNUtNSmc4SV9ZdEE&hl=ko#gid=0
* 다시 자바로 따라해보기를 하면서 익혀보자.