프로그램 분류
1. 절차적 프로그래밍
1.2 구조적 프로그래밍(???)
1.5 WEB의 발전, 세션단위(stateless)
2. 객체지향적 프로그래밍\
2.5 데이터베이스 시스템(대용량 처리를 위한.. : 트랜잭션 이슈 처리)
3. 비동기 프로그래밍
4. 함수형 프로그래밍

절차적 프로그래밍은 작은 단위의 프로그램을 할때 좋았다. 
하지만 점점 사람들은 많이 사용하게 되었고 프로그램들을 묶은 시스템을 만들게 되었다.
큰 시스템은 설계를 위한 형식이 필요하게 되었고, 그것을 만족한것이 객체지향 프로그래밍이었다.
하지만 세월은 또 변했다. 사람들은 객체지향에 익숙해졌지만... 
 

객체지향 프로그래밍 
> 객체 지향 프로그래밍(이하 OOP)는 컴퓨터 프로그램을 “객체(Object)"들의 모임으로 파악하고자 하는 프로그래밍의 패러다임 중에 하나이다. 각 “객체(Object)" 들은 서로 메시지를 주고 받을 수 있으며 데이터를 처리할 수 있다.

객체지향 참조(단어정의) : https://www.slideshare.net/plusjune/ss-46109239
객체지향 참조 : https://medium.com/@ehddnjs8989/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EA%B8%B0%EC%B4%88-oop-c50a7701223e
객체지향 5원칙(SOLID) : https://dev-momo.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%99

1. 프로그램을 유연하고 변경이 용이하게 만든다.
  - 유연성 : 해당 프로그램가지고 다른것을 개발하려면 힘들다. 새로 만들어야 할 정도가 될수도 있다.
  - 변경성 : 비슷한 로직이 여기저기 흩어져 있다. 다 찾아 보려면 
2. 프로그램의 개발과 보수를 간편하게 만든다.
  - 문서로 만드는 것이 가능하다.
  - UML등으로 소스를 좀더 잘 볼수 있게 되었다.
3. 직관적인 코드 분석   

위의 장점들을 관통하는 객체 지향 프로그래밍의 중요한 특성은 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향한다는 점이다.

소프트웨어 공학에서 말하는,
응집력(cohesion) : 프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도. 프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있고, 지나치게 많은 일을 하지 않으면 그것을 응집력이 높다고 표현한다.

결합력(coupling) : 프로그램 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 얼마나 의존적인지를 나타내는 정도. 결합력이 낮다는 것은 한 요소가 다른 요소들과 관계를 크게 맺고 있지 않은 상태를 의미한다.

* OOP의 경우 클래스에 하나의 문제 해결을 위해 데이터를 모아 놓은 객체를 활용한 프로그래밍을 지향하므로 응집력을 강화하며, 클래스 간에 독립적으로 디자인함으로써 결합력을 약하게 할 수 있다.


OOP의 특성
1. 캡슐화(Encapsulation)
  캡슐화는 객체의 데이터를 외부에서 직접 접근하지 못하게 막고, 함수를 통해서만 조작이 가능하게 하는 작업이다.

2. 추상화(Abstraction)
  추상화는 객체들이 가진 공통의 특성들을 파악하고 불필요한 특성들을 제거하는 과정을 말한다. 객체들이 가진 동작들을 기준으로 이용자들이 동작만 쉽게 구동할 수 있도록 한다. 몬스터의 예제에서 레벨업(levelUp) 메소드를 실행만 하면 level이라는 속성을 컨트롤 할 수 있었던 것처럼.
  이러한 추상화 과정을 통해 이용자들은 프로그래머가 만든 객체를 더 쉽게 사용할 수 있게 된다.
  추상화를 할 때 주의할 점은 속성 위주가 아닌 동작 위주로 정의하는 작업을 하는 것이다. 객체의 동작에 연관이 되지 않는 속성들은 결국은 불필요하다. 따라서 불필요한 속성들을 걸러내기 위해 동작을 먼저 정의하고 동작에 필요한 속성들을 정리하는 것이 좋다.

3. +α 재사용성
  몬스터를 여러 마리 만들어야 한다. 각 몬스터들은 모두 같은 속성을 가지고 있다. 몬스터 객체를 이용하여 모든 몬스터들이 같은 속성과 메소드를 가질 수 있도록 만들 수 있다.
  OOP의 가장 큰 특성 중 하나가 바로 코드의 재사용성과 상속의 개념이다. 같은 객체를 여러 개 만들어야 하는 경우, 한 번 작성된 코드를 활용하여 동일한 객체를 만들 수 있다.


> 코드가 업무와 섞여 있는 문제를 해결해야한다. 안그러면 업무를 아는 사람만이 수정을 할수 있게 되기 때문이다.

> 하지만 객체지향은 너무 형식에 억매이게 된다. 취지는 좋았는데... 그것도 사람이 하는 것이라고 그럴까? 
>> 또한 무거워지기 시작하고, 복잡해지기 시작했다. 물론 잘못된 방법이 어서 그렇겠지만 말이다.  

## 객체지향 살펴보기
* [객체지향이란](https://velog.io/@cyranocoding/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DOOP-Object-Oriented-Programming-%EA%B0%9C%EB%85%90-%EB%B0%8F-%ED%99%9C%EC%9A%A9-%EC%A0%95%EB%A6%AC-igjyooyc6c)
  - 컴퓨터 프로그램을 “객체(Object)"들의 모임으로 파악하고자 하는 프로그래밍의 패러다임
  

---

패턴의 분류
참조 자료 : https://gmlwjd9405.github.io/2018/07/06/design-pattern.html
> 소프트웨어를 설계할 때 `특정 맥락`에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 `재사용`할 할 수있는 훌륭한 `해결책`

디자인 패턴 구조
1. 콘텍스트(context)
    문제가 발생하는 여어 상황을 기술한다. 즉, 패턴이 적용될 수 있는 상황을 나타낸다.
    경우에 따라서는 패턴이 유용하지 못한 상황을 나타내기도 한다.
2. 문제(problem)
    패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 기술한다.
    이때 여러 제약 사항과 영향력도 문제 해결을 위해 고려해야 한다.
3. 해결(solution)
    문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술한다.
    해결은 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿이다.
    디자인 패턴의 종류
    
GoF 디자인 패턴 분류
1. 생성 패턴(Creational) : 객체 생성을 할때 공통적으로 나타나는 문제 해결
  - 싱글턴, 팩토리 메소드, 추상 팩토리, 프로토타입, 빌더 패턴
2. 구조 패턴(Structural) : 자주 사용되는 객체들로 구성된 구조를 본다
  - 스트래티지, 옵저버, 스테이트, 커맨드, 이터레이터, 템플릿 메소드, 인터프리터, 미디에이터, 역할 변경, 메멘토, 비지터
3. 행위 패턴(Behavioral) : 동적 코드를 구현할때 나타나는 공통된 문제 해결    
  - 데코레이터, 어댑터, 컴포지트, 퍼사드, 프록시, 브리지, 플라이웨이트

클래스/객체로 패턴 분류

1. 클래스 패턴 (Class Pattern) : 클래스 사이의 관계가 상속을 통해서 어떤 식으로 정의되는지를 다룬다. 클래스 패턴은 컴파일시에 관계가 결정된다.
  - 템플릿 메소드, 팩토리 메소드, 어댑터, 인터프리터

2. 객체 패턴 (Object Patterns) : 객체 사이의 관계를 다루며, 객체 사이의 관계는 보통 구성을 통해서 정의된다. 객체 패턴에서는 일반적으로 실행 중에 관계가 생성되기 때문에 더 동적이고 유연하다.
  - 스트래티지, 옵저버, 데코레이터, 프록시, 컴포지트, 이터레이터, 스테이트, 추상 팩토리, 싱글턴, 비지터, 메멘토, 역할 사슬, 브리지, 미디에이터, 플라이웨이트, 프로토타입, 빌더



* 영어를 해석하면 각 패턴을 이해하기 쉬울때가 있다.  